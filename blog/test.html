<!DOCTYPE html>
<html lang="en"><head>
		<meta charset="utf-8">
		<meta http-equiv="Permissions-Policy" content="interest-cohort=()">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="icon" type="image/svg+xml" href="favicon.svg">
		<link rel="stylesheet" type="text/css" href="styles.css">
		<script type="module" src="render.js"></script>
		<title>A&nbsp;Dream of&nbsp;the&nbsp;Perfect Programming Language</title>
	</head>
	<body>
<nav><ul><li><a href="#a-dream-of-the-perfect-programming-language">A&nbsp;Dream of&nbsp;the&nbsp;Perfect Programming Language</a><ul><li><a href="#appendix-on-turing-completeness">Appendix: On&nbsp;Turing Completeness</a></li></ul></li></ul></nav><main>
<h1 id="a-dream-of-the-perfect-programming-language" tabindex="-1">A&nbsp;Dream of&nbsp;the&nbsp;Perfect Programming Language</h1>
<p>This&nbsp;is a&nbsp;quick summary of&nbsp;what I&nbsp;imagine The&nbsp;Perfect Programming Language™ would look like. I&nbsp;plan to&nbsp;write a&nbsp;more comprehensive article that will, hopefully, slowly evolve into an&nbsp;informal specification for my&nbsp;own future language, but I&nbsp;don’t have time for&nbsp;it right now. Plus, I&nbsp;need way more education and&nbsp;research.</p>
<p>Still, I&nbsp;believe I&nbsp;do&nbsp;have some valuable things to&nbsp;say, as&nbsp;I&nbsp;suspect some of&nbsp;these ideas or&nbsp;combinations of&nbsp;them are original or&nbsp;at&nbsp;least not well-known in&nbsp;the&nbsp;mainstream (and some are obvious but still need repeating). Also, some of&nbsp;them are already clear from the&nbsp;first item but are worth reiterating and can&nbsp;be implemented separately (incrementalism&nbsp;FTW).</p>
<p>For now, I’m&nbsp;barely gonna justify any of&nbsp;them and will try not to&nbsp;respond to&nbsp;criticism, unless I&nbsp;can’t stop myself (again, the&nbsp;lack of&nbsp;time). Thus, the&nbsp;target audience for this article are people who already more or&nbsp;less share my&nbsp;approach to&nbsp;programming and don’t need to&nbsp;be&nbsp;convinced.</p>
<p>Who knows, maybe some of&nbsp;them will pick&nbsp;up an&nbsp;idea or&nbsp;two that they don’t already know and put them to&nbsp;the&nbsp;test in&nbsp;their own pet languages or&nbsp;even in&nbsp;some mainstream ones they happen to&nbsp;contribute&nbsp;to.</p>
<p>I&nbsp;do&nbsp;understand that not all of&nbsp;these ideas may rest solely on&nbsp;well-established theory (especially the&nbsp;one in&nbsp;the&nbsp;appendix) and that some of&nbsp;them still have unsolved problems, but my&nbsp;limited knowledge of&nbsp;computer science leads&nbsp;me to&nbsp;beleive that nothing on&nbsp;this list is&nbsp;impossible or&nbsp;impractical in&nbsp;the&nbsp;long&nbsp;run.</p>
<p><strong>The&nbsp;general idea</strong> is&nbsp;to&nbsp;maximize safety and expressiveness without introducing any runtime overhead, by&nbsp;use of&nbsp;various language and library features that automate coding and make the&nbsp;high-level code <strong>purely semantic,</strong> since the&nbsp;low-level technical details are usually pretty mechanical and do&nbsp;not require a&nbsp;human-level general intelligence in&nbsp;every specific&nbsp;case.</p>
<p>And finally, not that anybody asked, but to&nbsp;explain some of&nbsp;my&nbsp;perspective, the&nbsp;languages I&nbsp;come from are: <strong>C&nbsp;→ C++&nbsp;→ Python&nbsp;→ Modern C++&nbsp;→ Haskell&nbsp;→&nbsp;Rust.</strong></p>
<p>Anyway, here goes&nbsp;nothing:</p>
<ol>
<li>The&nbsp;language must&nbsp;be <strong>purely functional.</strong> Functional code is&nbsp;easier to&nbsp;reason and make guarantees about, and it’s easier to&nbsp;integrate with dependent types (see below). Not to&nbsp;mention how elegant it&nbsp;can&nbsp;be (try Haskell if&nbsp;you haven’t). You can easily find heaps of&nbsp;articles explaining this point better, so&nbsp;I’m&nbsp;not gonna linger&nbsp;on&nbsp;it.</li>
<li>It&nbsp;should rely on&nbsp;<strong>zero-cost abstractions</strong> to&nbsp;be as&nbsp;fast as&nbsp;C/C++/Rust (more specifics&nbsp;below).</li>
<li><strong>Compile time</strong> is&nbsp;important, but it’s&nbsp;ok to&nbsp;sacrifice&nbsp;it to&nbsp;reduce <strong>design time, debug time</strong> and <strong>runtime.</strong> Machine time is&nbsp;much cheaper than human time, and once you automate a&nbsp;task, a&nbsp;machine runs&nbsp;it more efficiently and reliably. And runtime gets multiplied by&nbsp;the&nbsp;number of&nbsp;devices that run&nbsp;it and the&nbsp;number of&nbsp;times&nbsp;it&nbsp;is&nbsp;run.</li>
<li>Probably compile to&nbsp;C; that automatically gives&nbsp;a&nbsp;language total platform coverage, since every toaster has&nbsp;a&nbsp;C&nbsp;compiler.</li>
<li>The&nbsp;type system must&nbsp;be <strong>inferred, strong,&nbsp;static.</strong></li>
<li>Use sum types (e.&nbsp;g.&nbsp;<code>Maybe</code>/<code>Option</code>) for <strong>recoverable</strong> errors like Haskell and&nbsp;Rust&nbsp;do.</li>
<li>Instead&nbsp;of using panics&nbsp;or, goodness forbid, <s>glorified <code>goto</code></s> exceptions, prevent <strong>unrecoverable</strong> errors on&nbsp;one hand and double checks on&nbsp;the&nbsp;other with <strong>dependent types</strong> (including some <strong>axioms</strong> for hardware input ranges listed in&nbsp;specs). Ideally, the&nbsp;language should&nbsp;be <a href="https://en.wikipedia.org/wiki/Total_functional_programming"><strong>total</strong></a> (see the&nbsp;appendix). If&nbsp;we&nbsp;can’t have that without making&nbsp;it unusable, Rust-style panics are the&nbsp;lesser&nbsp;evil.</li>
<li>The&nbsp;standard <strong>integer</strong> type should mimic the&nbsp;C++ <a href="https://github.com/davidstone/bounded-integer">bounded::integer</a> library (but with multiple ranges): instead&nbsp;of choosing between <code>(u)int8/16/32/64/BigInt</code> yourself, you just choose ranges of&nbsp;possible values, and it&nbsp;statically infers ranges that result from operations. In&nbsp;a&nbsp;dependently typed language, it&nbsp;could, for example, be&nbsp;a&nbsp;bounded <code>Nat</code> with <code>int</code> types as&nbsp;compiler optimizations (currently, even Idris only <a href="https://github.com/idris-lang/Idris-dev/pull/4685">replaces</a> <code>Nat</code> with&nbsp;<code>BigInt</code>).</li>
<li>It&nbsp;is possible that for competing with&nbsp;C in&nbsp;terms of&nbsp;performance, it&nbsp;would still need some kind of&nbsp;<strong><code>unsafe</code></strong> blocks where imperative code is&nbsp;allowed&nbsp;— and maybe even pointer manipulation. Even better if&nbsp;there could&nbsp;be a&nbsp;sublanguage for writing custom optimizations, ideally with formal proofs of&nbsp;their correctness. Either way, they should mostly be&nbsp;used in&nbsp;low-level libraries and not in&nbsp;ordinary&nbsp;code.</li>
<li>There should&nbsp;be no&nbsp;dynamic <strong>garbage collector.</strong> And while Rust’s borrow checker is&nbsp;pure awesomeness, it&nbsp;has a&nbsp;high entry threshold (unless you’re coming from&nbsp;C++ and are tired of&nbsp;manually keeping track of&nbsp;lifetimes). I&nbsp;think we&nbsp;can do&nbsp;better. The&nbsp;choice between <strong>copying, borrowing</strong> and <strong>moving</strong> could&nbsp;be made automagically based on&nbsp;the&nbsp;last use (after the&nbsp;compiler decides on&nbsp;the&nbsp;order of&nbsp;operations), the&nbsp;size of&nbsp;the&nbsp;object and how it’s used in&nbsp;the&nbsp;callee (I’m&nbsp;not sure, maybe whole program analysis is&nbsp;necessary for that&nbsp;— or&nbsp;some kind of&nbsp;interface for TUs to&nbsp;talk during&nbsp;compilation).</li>
<li><strong>Mutable state</strong> is&nbsp;an&nbsp;awesome compiler optimization and should&nbsp;be used whenever possible. <strong>Linear types</strong> in&nbsp;some capacity should help with&nbsp;it&nbsp;— and with static memory&nbsp;management.</li>
<li>Use <strong>strict</strong> evaluation by&nbsp;default but have <strong>lazy</strong> iterators/lists (not linked lists though) that are compiled into imperative loops. As&nbsp;far as&nbsp;I&nbsp;know, lazy evaluation by&nbsp;default is&nbsp;the&nbsp;main reason Haskell can’t have <s>nice things</s> a&nbsp;static garbage&nbsp;collector.</li>
<li><strong>Vectors</strong> should&nbsp;be iterable without any intermediate <code>iter()</code> calls. Maybe it’s better if&nbsp;the&nbsp;choice between a&nbsp;vector and a&nbsp;<strong>lazy iterator</strong> is&nbsp;made by&nbsp;the&nbsp;compiler, based on&nbsp;how you construct and&nbsp;use&nbsp;it.</li>
<li>For string representation, use <a href="http://utf8everywhere.org">UTF-8&nbsp;everywhere</a>.</li>
<li><strong><code>constexpr</code></strong> all the&nbsp;things! If&nbsp;it can&nbsp;be done in&nbsp;compile time, it&nbsp;should&nbsp;be. And whether something is&nbsp;really done at&nbsp;compile time or&nbsp;at&nbsp;runtime is&nbsp;a&nbsp;low-level implementation detail with&nbsp;no&nbsp;semantics.</li>
<li>Ideally, the&nbsp;compiler together with constructor functions from the&nbsp;standard library should themselves choose between static and dynamic arrays, strings and string views, associative data structures and their <a href="https://github.com/serge-sans-paille/frozen">frozen twins</a> etc. based on&nbsp;<code>constexpr</code>ness of&nbsp;them and their sizes, <code>const</code>ness (based on&nbsp;usage), bounds from dependent types and other static&nbsp;clues.</li>
<li>Whether it’s via the&nbsp;<code>State</code> monad, linear types or&nbsp;something else, convenient <strong>hash maps</strong> should definitely be&nbsp;a&nbsp;thing. Losing such a&nbsp;fundamental data structure is&nbsp;not an&nbsp;acceptable&nbsp;trade‑off.</li>
<li>There should&nbsp;be no&nbsp;traditional, inheritance-based OOP, only algebraic data types, typeclasses/traits and pattern matching. And possibly Rust-style <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait objects</a> for dynamic dispatch: vtables are faster than pattern-matching, and I&nbsp;think sometimes it&nbsp;is the&nbsp;right&nbsp;solution.</li>
<li>Haskell/Idris syntax is&nbsp;mostly awesome,&nbsp;use&nbsp;it.</li>
<li><strong>First-class functions</strong> are a&nbsp;must, and so&nbsp;is&nbsp;<strong>currying.</strong> Pointfree programming is&nbsp;beautiful and consice when not overdone, and having lambdas everywhere is&nbsp;ugly because explicit arguments in&nbsp;them mix abstraction&nbsp;levels.</li>
<li>Copy Rust’s editions, module system and&nbsp;Cargo.</li>
<li><strong>The&nbsp;standard library</strong> should&nbsp;be well-designed and built&nbsp;up steadily but should eventually include even things like audio and graphics (and way before that&nbsp;— cryptography). If&nbsp;it’s not an&nbsp;unsolved mathematical problem, there’s no&nbsp;reason it&nbsp;can’t have a&nbsp;standard solution. The&nbsp;same common problems getting solved by&nbsp;different people is&nbsp;a&nbsp;waste of&nbsp;man‑hours that can&nbsp;be spent developing something&nbsp;new.</li>
</ol>
<h2 id="appendix-on-turing-completeness" tabindex="-1">Appendix: On&nbsp;Turing Completeness</h2>
<p>This isn’t something I&nbsp;have fully reflected upon, but I&nbsp;have a&nbsp;strong suspicion that Turing completeness is&nbsp;overrated and no&nbsp;useful program actually needs&nbsp;it. In&nbsp;short: when you write or&nbsp;debug code, you’re already doing halting analysis in&nbsp;your head, however imperfectly. Your human brain is&nbsp;limited in&nbsp;its abilities, and most languages don’t offer enough help in&nbsp;this regard, but you never actually <strong>want</strong> your code to&nbsp;do unpredictable things (even in&nbsp;machine learning and cryptography, it’s domesticated, predictable unpredictability). You want its behaviour to&nbsp;be deterministic, you want&nbsp;it to&nbsp;do what you’ve told&nbsp;it&nbsp;to. Thus, (I&nbsp;speculate) all that unprovable stuff is&nbsp;garbage, and all you need is&nbsp;a&nbsp;reliable total&nbsp;subset.</p>
<p>In&nbsp;<a href="https://news.ycombinator.com/item?id=10449616">other&nbsp;words</a>,</p>
<blockquote>
<p>The&nbsp;halting problem merely prevents a&nbsp;program from evaluating a&nbsp;nontrivial property of&nbsp;another program with perfect accuracy. It&nbsp;does not prevent a&nbsp;program from evaluating a&nbsp;nontrivial property (bound checks, type safety, whatever) with possible outputs “Yes” or&nbsp;“Either&nbsp;no, or&nbsp;you’re trying to&nbsp;trick&nbsp;me, so&nbsp;cut that out and express what you mean more straightforwardly&nbsp;kthx”.</p>
</blockquote>
</main></body></html>
